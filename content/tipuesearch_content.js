var tipuesearch = {"pages": [{'title': '關於本網站', 'text': '本網站的設置目的： \n 1.記錄網際網絡管理課程的課程內容 \n 2.課外知識的紀錄 \n 3.期中影片介紹用與期末網站介紹用', 'tags': '', 'url': '關於本網站.html'}, {'title': '課程內容', 'text': '學習項目： \n 1.架設網站 \n 2.建立 blogger 並使用 \n 3.IPV4,IPV6及proxy介紹 \n 4.google各項工具介紹 \n 5.obs,shareX的介紹及應用 \n 6.leo的使用\xa0 \n \n \n', 'tags': '', 'url': '課程內容.html'}, {'title': 'W2', 'text': '', 'tags': '', 'url': 'W2.html'}, {'title': '架設網站', 'text': 'step1：建立github帳號 \n step2：建立508331**的倉儲，設定為公開(**為學號) \n step3：到mde.tw中下載wcmj2020 \n step4：開啟start.bat ，將建立的網站網址 git clone ，再從 tmp 進到 wcmj2020 再進到 cmsimde 利用python 開啟近端，輸入密碼 admin 。再將網站名字改為自己的學號，輸入自己的筆記重點。最後按下 generate_pages 轉為靜態網站。 \n step5：再回到 start.bat 輸入cd .. (cd .. 為退回上個資料夾) \n step6：輸入git add . \n step7：輸入 git commit -m "**"(**為檔案名稱) \n step8：最後輸入 git push ，輸入 github 的帳號密碼即可上傳至遠端，網站即可建立完成 \n', 'tags': '', 'url': '架設網站.html'}, {'title': 'W3', 'text': '', 'tags': '', 'url': 'W3.html'}, {'title': '建立blogger', 'text': 'step1： 登入google帳號，到blogger點選新增網誌 \n step2： 輸入網誌名稱 \n step3： 輸入網誌網址，網 址的格式為 ******.blogspot.com \n step4：按下加鍵即可新增 \n 50833112 blogger \n \n \n \n \n \n \n', 'tags': '', 'url': '建立blogger.html'}, {'title': 'W7', 'text': '', 'tags': '', 'url': 'W7.html'}, {'title': '如何使用meet', 'text': '登入google帳號，進到 https://meet.google.com/ ，按下發起會議即可。 \n 若只想讓一些人加入會議，只需要將meet的連結發給特定的人即可。\xa0 \n \xa0 \n', 'tags': '', 'url': '如何使用meet.html'}, {'title': '介紹obs及ShareX', 'text': 'obs \n 錄製工具，畫質較高 \n ShareX \n 截圖、修圖、翻譯功能 \n', 'tags': '', 'url': '介紹obs及ShareX.html'}, {'title': 'W8', 'text': '', 'tags': '', 'url': 'W8.html'}, {'title': '810 proxy setting', 'text': '2001:288:6004::"53,42,17,7,4(擇其一)"(140.130.17.4:3128) \n \n', 'tags': '', 'url': '810 proxy setting.html'}, {'title': '公告', 'text': '會議：meet.google.com \n w9在線上上課 \n 組別組員： 50833110 \xa0 50833112 \xa0 50833115 \xa0 50833123 \xa0 50833127 \xa0 50833128 \xa0 50833129 \xa0 50833131 \xa0 50833133 \xa0 50833138 \n', 'tags': '', 'url': '公告.html'}, {'title': 'W1-W9', 'text': '', 'tags': '', 'url': 'W1-W9.html'}, {'title': '程式、網站', 'text': '1.程式用語 \n 2.介紹google的內建程式(ex: google meet, google drive, calendar) \n 3.架設網站 \n \n', 'tags': '', 'url': '程式、網站.html'}, {'title': 'W10', 'text': '', 'tags': '', 'url': 'W10.html'}, {'title': '特殊名詞', 'text': 'Public key \xa0 公開密鑰加密 \n Cryptography \xa0 編碼學 \n SSH(Secure Shell) \xa0 安全編碼機制 \n', 'tags': '', 'url': '特殊名詞.html'}, {'title': 'SSH', 'text': '\n SSH簡略介紹 \n 1.SSH \xa0是 \xa0 Secure Shell \xa0 的縮寫 \n 2.由   IETF \xa0 的網路工作小組（ Network Working Group \xa0 ）所制定 \n 3.為建立在應用層和傳輸層基礎上的安全協議 \n 4.透過安全的連線登入遠端主機執行命令的一個協定 \n 目的 \n 傳統的網路服務程序，在本質上都是不安全的。原因為它會將的你的資料用明文傳送到網絡上，很容易被他人擷取資料。這種服務程序的安全驗證方式也有其弱點，就是很容易受到"中間人"（man-in-the-middle）這種方式的攻擊。 \n 所以我們可以通過使用SSH，將傳輸的資料進行加密，而就無法達成中間人這種攻擊方式，並且也能夠防止DNS和IP欺騙。另一項好處是傳輸資料的速度會加快，原因為資料是經過壓縮後才傳輸的。 \n SSH 協議框架中最主要三個協議 \n 傳輸層協議（The Transport Layer Protocol） \n 用戶認證協議（The User Authentication Protocol） \n 連接協議（The Connection Protocol） \n \n', 'tags': '', 'url': 'SSH.html'}, {'title': 'W12', 'text': '', 'tags': '', 'url': 'W12.html'}, {'title': 'leo', 'text': '\n 指令 \n Shift - Down - arrow   ( move - outline - down ) \n Shift - Left - arrow   ( move - outline - left ) \n Shift - Right - arrow   ( move - outline - right ) \n Shift - Up - arrow   ( move - outline - up ) \n Ctrl - D   ( move - outline - down ) \n Ctrl - L   ( move - outline - left ) \n Ctrl - R   ( move - outline - right ) \n Ctrl - U   ( move - outline - up ) \n Ctrl - C   ( copy - text ) \n Ctrl - K   ( kill ) \n Ctrl - V   ( paste - text ) \n Ctrl - X   ( cut - text ) \n Ctrl - Y   ( yank ) \n Alt - Y    ( yank - pop ) \n Ctrl - N   ( new ) \n Ctrl - O   ( open - outline ) \n Ctrl - S   ( save - file ) \n Ctrl - Q   ( exit - leo ) \n Alt - T   ( focus - to - tree ) \n Ctrl - T   ( toggle - active - pane ) \n Ctrl - Tab   ( tab - cycle - next ) \n Ctrl - I   or   Insert   ( insert - node ) \n Ctrl - H   ( edit - headline ) \n < Return >   ( when   editing   a   headline )   ( end - edit - headline ) \n Ctrl - Shift - C   ( copy - node ) \n Ctrl - Shift - X   ( cut - node ) \n Ctrl - Shift - V   ( paste - node ) \n Ctrl - {   ( promote ) \n Ctrl - }   ( demote ) \n Ctrl - M   ( mark ) \n \n \xa0 \n \n', 'tags': '', 'url': 'leo.html'}, {'title': '建立網誌', 'text': "step1: 利用瀏覽器進入  mde.tw  到實習項目中下載 wcmj2020_tool.7z \n step2: 解壓縮 wcmj2020_tool.7z 後 進入 start.bat 輸入指令開啟leo(指令輸入leo即可) \n step3: 利用leo開啟 pelican.leo 修改 共用: AUTHOR = '50833112' SITENAME = '名稱' 遠端的SITEURL \n step4:在2018 Fall CP 課程中按 Ctrl+i 新增網誌 \n step5: 存取 local-blog 後再利用 start.bat 輸入 \n Y:>cd tmp \n Y:\\tmp>cd wcmj2020 \n Y:\\tmp\\wcmj2020>pelican markdown -o blog -s publishconf.py \n step6: 最後到 https://localhost:8444 確認blog 是否有推上去 \n", 'tags': '', 'url': '建立網誌.html'}, {'title': 'W13-14', 'text': 'Pelican Blog 內容與 Google Blogger 同步 \n', 'tags': '', 'url': 'W13-14.html'}, {'title': '利用leo更新blogger', 'text': 'step1: 利用google chrome 開啟 https://console.developers.google.com/ \xa0，建立一把desktop client的金鑰。啟動 blogger API V3 存在tmp下建立檔名"client_secrets.json" \n step2: 利用start.bat 開起 leo \n step3: 建立 add_to_blogger & edit_to_blogger，從mde.tw中的wcmj2020 w12-13分別複製程式碼。 \n step4: 將所寫日誌改為 @clean 起頭，將內文存取到文章標題下一節 \n step5: 按下按鈕add_to_blogger，上傳文章到blogger \n', 'tags': '', 'url': '利用leo更新blogger.html'}, {'title': 'add_to_blogger', 'text': '@language python\nfrom markdown import markdown\nfrom oauth2client import client\n#from googleapiclient import sample_tools\nimport os\n# 配合使用 credential token\nimport pickle\nfrom googleapiclient.discovery import build\n#from google_auth_oauthlib.flow import InstalledAppFlow\n#from google.auth.transport.requests import Request\n \nos.environ[\'TZ\'] = \'Asia/Taipei\'\nwith open(\'./../../blogger_credentials.dat\', \'rb\') as credentials_dat:\n    credentials = pickle.load(credentials_dat)\nservice = build(\'blogger\', \'v3\', credentials=credentials)\n \ndef get_cat_tag_content(data):\n    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---\n    # 用跳行符號分割\n    data_list = data.split("\\n")\n    #第 2 行為 title\n    title= data_list[1]\n    #第 4 行為 category\n    category = data_list[3]\n    #第 5 行為 tags\n    tags = data_list[4]\n    # 有多項資料的 content 型別為數列\n    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料\n    content = "\\n".join(data_list[8:])\n    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 <!--more-->\n    content = content.replace(\'<!-- PELICAN_END_SUMMARY -->\', \'<!--more-->\')\n    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式\n    #content = content.replace(\'~~~python\', \'[code lang="python"]\')\n    #content = content.replace(\'~~~\', \'[/code]\')\n    return title, category, tags, content\n \n# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容\n# p.h 為 @clean filename.md\n# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案\nmd_filename = p.h.split(" ")[1]\nwith open(md_filename, \'r\', encoding="utf-8") as content_file:\n    md_content = content_file.read()\n# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)\ntitle_str, category_str, tags_str, content = get_cat_tag_content(md_content)\ncategory = category_str.split(":")[1]\ntags = tags_str.split(":")[1].split(",")\ntags.append(category)\n# title 是一個單獨的字串\ntitle = title_str.split(":")[1]\n# 將 markdown 格式 content 轉為 html\ncontent = markdown(content)\n# 以下處理 content 的 <h2> 標題\ncontent = content.replace("<h2>", "<h2><font size=\'4\'>")\ncontent = content.replace("</h2>", "</font></h2>")\n# g.es(content)\n \ntry:\n    \'\'\'\n    users = service.users()\n    # 取得使用者 profile 資料\n    user = users.get(userId=\'self\').execute()\n    print(\'網誌名稱: %s\' % user[\'displayName\'])\n    \'\'\'\n    blogs = service.blogs()\n    # 取得使用者所建立網誌名稱\n    blogs = blogs.listByUser(userId=\'self\').execute()\n    # post_id is now blogs["items"][0]["id"]\n    blog_id = blogs["items"][0]["id"]\n    #for blog in blogs[\'items\']:\n        #print(blog[\'name\'], blog[\'url\'])\n    posts = service.posts()\n    # 新增網誌 post 時, 需要 post_id\n    body = {\n    "kind": "blogger#post",\n    "id": blog_id,\n    "title": title,\n    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容\n    "content": content,\n    "labels": tags\n    }\n    insert = posts.insert(blogId=blog_id, body=body)\n    posts_doc = insert.execute()\n    post_id = posts_doc["id"]\n    #print(posts_doc)\n    # 改用 credential token 後不會產生 blogger.dat\n    #os.remove("blogger.dat")\n    # 利用最後的 child 節點來儲存 post_id\n    to_save_post_id = p.insertAsLastChild()   \n    # 改為內文為空的節點, id 直接標在 head 標題 \n    to_save_post_id.b = ""\n    to_save_post_id.h = post_id\n    # 因為新增節點, commander 必須 redraw\n    c.redraw()\n    g.es("post_id 為", post_id)\n    g.es("已經將資料送往 Blogger!")\nexcept(client.AccessTokenRefreshError):\n    g.es("error") \n \n \n', 'tags': '', 'url': 'add_to_blogger.html'}, {'title': 'edit_to_blogger', 'text': '@language python\nfrom markdown import markdown\nfrom oauth2client import client\n#from googleapiclient import sample_tools\nimport os\n# 配合使用 credential token\nimport pickle\nfrom googleapiclient.discovery import build\n#from google_auth_oauthlib.flow import InstalledAppFlow\n#from google.auth.transport.requests import Request\n \nos.environ[\'TZ\'] = \'Asia/Taipei\'\nwith open(\'./../../blogger_credentials.dat\', \'rb\') as credentials_dat:\n    credentials = pickle.load(credentials_dat)\nservice = build(\'blogger\', \'v3\', credentials=credentials)\n \ndef get_cat_tag_content(data):\n    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---\n    # 用跳行符號分割\n    data_list = data.split("\\n")\n    #第 2 行為 title\n    title= data_list[1]\n    #第 4 行為 category\n    category = data_list[3]\n    #第 5 行為 tags\n    tags = data_list[4]\n    # 有多項資料的 content 型別為數列\n    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料\n    content = "\\n".join(data_list[8:])\n    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 <!--more-->\n    content = content.replace(\'<!-- PELICAN_END_SUMMARY -->\', \'<!--more-->\')\n    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式\n    #content = content.replace(\'~~~python\', \'[code lang="python"]\')\n    #content = content.replace(\'~~~\', \'[/code]\')\n    return title, category, tags, content\n \n# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容\n# p.h 為 @clean filename.md\n# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案\nmd_filename = p.h.split(" ")[1]\nwith open(md_filename, \'r\', encoding="utf-8") as content_file:\n    md_content = content_file.read()\n# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)\ntitle_str, category_str, tags_str, content = get_cat_tag_content(md_content)\ncategory = category_str.split(":")[1]\ntags = tags_str.split(":")[1].split(",")\ntags.append(category)\n# title 是一個單獨的字串\ntitle = title_str.split(":")[1]\n# 將 markdown 格式 content 轉為 html\ncontent = markdown(content)\n# 以下處理 content 的 <h2> 標題\ncontent = content.replace("<h2>", "<h2><font size=\'4\'>")\ncontent = content.replace("</h2>", "</font></h2>")\n# g.es(content)\n \ntry:\n    blogs = service.blogs()\n    # 取得使用者所建立網誌名稱\n    blogs = blogs.listByUser(userId=\'self\').execute()\n    blog_id = blogs["items"][0]["id"]\n    # 設法取得原 post 的 id\n    postid_outline = p.getLastChild()\n    # 直接從標題取得 post 的 id 號碼\n    post_id = postid_outline.h\n    posts = service.posts()\n    # 更新網誌文章時的 body\n    body = {\n    "kind": "blogger#post",\n    "title": title,\n    "content": content\n    }\n    # need to save postId to outline head\n    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)\n    update_doc = update.execute()\n    # 使用 credential token 後, 無需刪除 blogger.dat\n    #os.remove("blogger.dat")\n    g.es("post_id 為", post_id)\n    g.es("已經將更新資料送往 Blogger!")\nexcept(client.AccessTokenRefreshError):\n    g.es("error") \n', 'tags': '', 'url': 'edit_to_blogger.html'}, {'title': 'W15~16', 'text': '將W1~W18的內容整理到自己的倉儲與網誌上並加上影音檔及圖片。可自訂主題，再 將分組協同的過程與內容整理在個人與分組的倉儲資料中 \n ===== \n', 'tags': '', 'url': 'W15~16.html'}, {'title': '第九週實習(期中報告)', 'text': '考試項目：電腦軟硬體簡介& 網路架構與設定簡介 \n \n \n', 'tags': '', 'url': '第九週實習(期中報告).html'}, {'title': '電腦軟硬體簡介', 'text': '電腦大致分為軟硬體。簡單說，軟體為摸不到的，硬體為摸的到的。軟體需要硬體才能使用，硬體沒有軟體也沒有用處。所以可以說，軟硬體缺一不可。 \n', 'tags': '', 'url': '電腦軟硬體簡介.html'}, {'title': '硬體', 'text': '硬體是電腦的物理裝置。系統轉體儲存在硬體內，包含認體（如BIOS）以及作業系統，系統軟體使應用軟體可以提供使用者所需的功能。作業系統通常藉由匯流排與裝置溝通，這就需要驅動程式。 \n 電腦硬體包括電腦的物理，有形部件或組件，例如機櫃，中央處理單元，監視器，鍵盤，電腦資料記憶體，圖形卡，音效卡，揚聲器和主機板。相比之下，軟體是可以由硬體儲存和執行的指令。硬體被認為是因為它在變化或修改方面「硬」或嚴格;而軟體是「軟」的，因為它很容易更新或更改。軟體和硬體之間的中間是「韌體」，它是與電腦系統的特定硬體強耦合的軟體，因此最難以改變，但在介面的一致性方面也是最穩定的。電腦系統中從「硬度」到「柔軟度」的級別的進展與計算中的抽象層的進展相似。 \n 主機板介紹 \n 主機板是硬體的主要部分。它是一塊大的方形板，上面有複雜的電路連接到電腦的其他部分，包含CPU ，RAM ，硬碟 ，光碟機（CD ，DVD ，或是其他的光碟），以及其他藉由插孔或是埠而連接的裝置。 \n 主機板組成 \n \n 1. 中央處理器(CPU 全名 Central\xa0Processing\xa0Unit) 處理電腦內大部分的計算，其被認為是電腦的大腦。它藉散熱器和風扇來降溫。新型的中央處理器包含圖形處理器。 \n 2. 晶片組（Chipset） ，作為中央處理器跟系統內其他元件兩者間的聯絡工具。 \n 3. 隨機存取記憶體（ RAM \xa0全名\xa0 Random\xa0Access\xa0Memory ） 儲存正在執行的作業系統以及所有正在執行的程式。 \n 4. BIOS 韌體 。它的英文全名是Basic\xa0Input/Output\xa0System。中文名為：基本輸入輸出系統。比較新的主機板使用 UEFI 來取代BIOS。 \n 5.內部 匯流排 用來連接中央處理器和電腦內部其他元件或是顯示卡，音效卡。 \n 來源 \n \n', 'tags': '', 'url': '硬體.html'}, {'title': '軟體', 'text': '系統軟體 \n 1、操作系統 \n 操作系統是底層的系統軟體，它是對硬體系統功能的首次擴充， \n 也是其他系統軟體和應用軟體能夠在電腦上運行的基礎。操作系統實際上是組程式，它們用於統一管理電腦中的各種軟、硬體資源，合理地組織電腦的工作流程，協調電腦系統各部分之間、系統與用戶之間、用戶與用戶之間的關係。操作系統在電腦系統中佔有非常重要的地位。 \n 操作系統提供人與機器的介面界面，具有5個方面的管理功能：存儲管理、處理器管理、設備管理、文件管理和進程管理。 \n 2、語言處理程式 \n 人們要利用電腦解決實際問題，首先要編製程式。程式設計語言就是用來編寫程式的語言，它是人與電腦之間交換信息的渠道。 \n 程式設計語言是軟體系統的重要組成部分，而相應的各種語言處理程式屬於系統軟體。程式設計語言一般分為機器語言、彙邊語言和高級語言3類。 \n 一.機器語言是底層的電腦語言。用機器語言編寫的程式，電腦硬體可以直接識別。 \n 二.彙編語言是為了便於理解與記憶，將機器語言用助記符代替而形成的一種語言。 \n 三.高級語言與具體的電腦硬體無關，其表達方式接近於人描述問題的方式，易為人們所接受和掌握。用高級語言編寫程式要比低級語言容易得多，並大大簡化了程式的編製和調試，使編程效率得到大幅度的提高。高級語言的顯著特點是獨立於具體的電腦硬體，並且通用性和可移植性好。 \n 語言處理程式就是把彙編或高級語言程式翻譯成電腦硬體可以直接處理的機器語言，存放於電腦記憶體中。供電腦系統執行。因此語言處理程式與程式設計語言、具體硬體類型是密切相關的，程式設計語言和硬體不同時，必須配以相應的語言處理程式。 \n 3、資料庫管理系統 \n 隨著電腦在信息處理、情報檢所及各種管理系統中應用的發展，要求大量處理某些數據，建立和檢索大量的表格。如果將這些數據和表格按一定的規律組織起來。可以使得這些數據和表格處理起來更方便，檢索更迅速，用戶使用更方便，於是出現了資造庫。資料庫就是相關數據的集合。資料庫和管理資料庫的軟體構成了資料庫管理系統。 \n 資料庫管理系統目前有許多種類型。例如，常用的關係資造庫有Access、Sybase、Oracle、SQI。Server和DB2等。 \n 4、服務程式 \n 服務程式有編輯程式、電腦硬體初始化程式和測試排錯程式等，主要用於電腦設備自身的應用服務。例如，記憶體檢查，優化管理，磁碟格式化、查錯，光碟寫入，網絡連接等都屬於服務程式。 \n 來源 \n 應用軟體 \n 應用程式（英語： application program ）或應用軟體（ application software ），簡稱應用（ app ），是電腦軟體的主要分類之一，是指為針對使用者的某種特殊應用目的所撰寫的電腦程式，例如文字處理器，表格，會計應用，瀏覽器，媒體播放器，航空飛行模擬器，命令行遊戲，圖像編輯器等。與之相對應的是主要功能為驅動電腦執行的系統軟體。或者說，應用軟體可以直接完成終端用戶的工作。從某種意義上來講，系統軟體是為應用軟體服務的，應用軟體才是真正直接 提高用戶工作的。 \n 來源 \n ======= \n', 'tags': '', 'url': '軟體.html'}, {'title': 'GIF', 'text': '\n \n', 'tags': '', 'url': 'GIF.html'}, {'title': '喵咪', 'text': '\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n', 'tags': '', 'url': '喵咪.html'}]};