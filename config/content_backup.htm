<h1>第九週實習</h1>
<p><span></span></p>
<h2>網路架構與設定簡介</h2>
<p><span></span></p>
<h2>電腦軟硬體簡介</h2>
<h3>硬體：</h3>
<h4><span>主機：</span></h4>
<p><span>1.機殼</span></p>
<p><span>2.電源</span></p>
<p><span>3.顯示卡</span></p>
<p><span>4.中央處理器(CPU)</span></p>
<p><span>5.主機板</span></p>
<p><span>6.音效卡</span></p>
<p><span>7.網路卡</span></p>
<h6><span>8.記憶體(RAM)</span></h6>
<h6><span>9.硬碟</span></h6>
<h6><span>10.光碟機</span></h6>
<p><span>11.軟碟機</span></p>
<h4><span>其他：</span></h4>
<p><span>1.螢幕</span></p>
<p><span>2.鍵盤</span></p>
<p><span>3.滑鼠</span></p>
<p><span>4.耳機</span></p>
<p><span>5.掃描器</span></p>
<p><span>6.印表機</span></p>
<p><span></span></p>
<h3>軟體：</h3>
<p><span>1.系統軟體</span></p>
<p><span>2.應用軟體</span></p>
<p>=======</p>
<p><span></span></p>
<h1>about</h1>
<h2>W2</h2>
<p><span>架設網站</span></p>
<h2>W3</h2>
<p>建立blogger</p>
<h2>W7</h2>
<h3>1.如何使用meet</h3>
<h3>2.介紹obs及ShareX</h3>
<h4>obs</h4>
<h5>錄製工具，畫質較高</h5>
<h4>ShareX</h4>
<h5>截圖、修圖、翻譯功能</h5>
<h2>W8</h2>
<h3>THU</h3>
<h4>English class:</h4>
<h5>word: network management, engineering graphics, mechanical design, mechanical workshop</h5>
<h3>FRI</h3>
<h4>810 proxy setting:</h4>
<h5>2001:288:6004::"53,42,17,7,4(擇其一)"(140.130.17.4:3128)</h5>
<h4>會議：meet.google.com</h4>
<h6>w9在線上上課</h6>
<h6>組別1：<span class="number">50833110</span><span><span> </span></span><span class="number">50833112</span><span><span> </span></span><span class="number">50833115</span><span><span> </span></span><span class="number">50833123</span><span><span> </span></span><span class="number">50833127</span><span><span> </span></span><span class="number">50833128</span><span><span> </span></span><span class="number">50833129</span><span><span> </span></span><span class="number">50833131</span><span><span> </span></span><span class="number">50833133</span><span><span> </span></span><span class="number">50833138</span></h6>
<h2>W1-W9</h2>
<h3>英文：</h3>
<p>大量英文單字</p>
<h3>程式、網站：</h3>
<p>程式用語</p>
<p>介紹google的內建程式(ex: google meet, google drive, calendar)</p>
<p><span></span></p>
<h2>W10</h2>
<h3>特殊名詞：</h3>
<p><span>Public key<span> </span></span>公開密鑰加密</p>
<p><span>Cryptography<span> </span></span>編碼學</p>
<p><span>SSH<span> </span></span>安全編碼機制</p>
<h3>SSH：</h3>
<p>安全編碼機制</p>
<p>Putty：A free SSH for Windows</p>
<p>設置目的：省略帳號密碼，保護個資</p>
<h2>W12</h2>
<p>step1: 利用瀏覽器進入 mde.tw 再進入 wcmj2020 到實習項目中下載 wcmj2020_tool.7z</p>
<p>step2: 解壓縮 wcmj2020_tool.7z 後 進入 start.bat 輸入指令開啟leo Y:&gt;cd tmp Y:\tmp&gt;cd wcmj2020 Y:\tmp\wcmj2020&gt;leo</p>
<p>step3: 利用leo開啟 pelican.leo 修改 共用: AUTHOR = '50833112' SITENAME = '名稱' 遠端的SITEURL</p>
<p>step4:在2018 Fall CP 課程中按 Ctrl+i 新增網誌</p>
<p>step5: 存取 local-blog 後再利用 start.bat 輸入 Y:&gt;cd tmp Y:\tmp&gt;cd wcmj2020 Y:\tmp\wcmj2020&gt;pelican markdown -o blog -s publishconf.py</p>
<p>step6: 最後到 https://localhost:8444 確認blog 是否有推上去</p>
<h2>W13-14</h2>
<p></p>
<h3>利用leo更新blogger</h3>
<p>step1: 利用google chrome 開啟<a href="https://console.developers.google.com/">https://console.developers.google.com/</a> ，建立一把desktop client的金鑰。啟動 blogger API V3 存在tmp下建立檔名"client_secrets.json"</p>
<p>step2: 利用start.bat 開起 leo</p>
<p>step3: 建立 add_to_blogger &amp; edit_to_blogger，從mde.tw中的wcmj2020 w12-13分別複製程式碼。</p>
<p>step4: 將所寫日誌改為 @clean 起頭，將內文存取到文章標題下一節</p>
<p>step5: 按下按鈕add_to_blogger，上傳文章到blogger</p>
<h3>add_to_blogger</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">@language python
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request
 
os.environ['TZ'] = 'Asia/Taipei'
with open('./../../blogger_credentials.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)
 
def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content
 
# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)
 
try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    blog_id = blogs["items"][0]["id"]
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    # 改用 credential token 後不會產生 blogger.dat
    #os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")</pre>
<p><br/><br/></p>
<p><span></span></p>
<h3>edit_to_blogger</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">@language python
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request
 
os.environ['TZ'] = 'Asia/Taipei'
with open('./../../blogger_credentials.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)
 
def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content
 
# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)
 
try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    blog_id = blogs["items"][0]["id"]
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    # 使用 credential token 後, 無需刪除 blogger.dat
    #os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")</pre>
<h1>Develope</h1>
<h1>GIF</h1>
<p><img alt="earth walks - GIF by Mila Magermans" src="https://cdn130.picsart.com/305196285203201.gif"/></p>
<h6><img alt="Egg (With images) | Cute gif, Animated gif, Gif" src="https://i.pinimg.com/originals/fd/3c/cd/fd3ccd7b49e366b4206f5ac7f8fa8dac.gif"/></h6>
<h1>cats</h1>
<p><img alt="yet yet cut cats (23) | Goneys | Flickr" src="https://live.staticflickr.com/8434/7793155944_188396324f_b.jpg"/></p>
<p><img alt="yet yet cut cats (7) | Goneys | Flickr" src="https://live.staticflickr.com/8298/7793166252_334475a33b_b.jpg"/>                       </p>
<p></p>